<!DOCTYPE html>
<html>
    <head>
        <title>AtmosphericX</title>
        <link rel="icon" href="/assets/media/dashboard/favicon.ico" type="image/x-icon">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
        <link rel="stylesheet" href="../widgets/interactive_map@widget/index.css">
        <link rel="stylesheet" href="../../assets/styles/streaming.css">
        <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
        <script src="../../assets/javascript/library.js"></script>
        <script src="../../assets/javascript/widgets.js"></script>
        <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
    </head>
    <body>
        <!-- Add the interactive map container -->
        <div id="interactive-map"></div>

        <!-- Add the alert list container -->
        <div id="alert-list">
            <h3>Active Alerts</h3>
            <ul id="alert-items"></ul>
        </div>

        <!-- Add the custom alert box -->
        <div id="custom-alert-box" style="position: absolute; top: 10px; left: 410px; color: white; padding: 5px; border-radius: 5px; display: none; z-index: 1000; width: 525px; height: auto; font-family: Arial, sans-serif;">
            <button id="alert-box-close" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 16px; cursor: pointer;">&times;</button>
            <div id="alert-box-event" style="font-size: 35px; font-weight: bold; text-transform: uppercase; text-align: center; margin-bottom: 15px; color: white; padding: 10px; border-radius: 5px;"></div>
            <div id="alert-box-expires" style="font-size: 25px; margin-bottom: 10px; color: white; padding: 5px; border-radius: 5px;"></div>
            <div id="alert-box-areas" style="font-size: 25px; margin-bottom: 10px; color: white; padding: 5px; border-radius: 5px;"></div>
            <div id="alert-box-max-wind" style="font-size: 25px; margin-bottom: 10px; color: white; padding: 5px; border-radius: 5px;"></div>
            <div id="alert-box-max-hail" style="font-size: 25px; margin-bottom: 10px; color: white; padding: 5px; border-radius: 5px;"></div>
        </div>

        <!-- Add radar toggle control -->
        <div id="radar-toggle" style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 4px; box-shadow: 0 0 10px rgba(0,0,0,0.2); font-family: Arial, sans-serif;">
            <div style="margin-bottom: 5px; font-weight: bold;">Radar Source:</div>
            <select id="radar-select" style="padding: 5px; width: 100%;">
                <option value="noaa">NOAA Radar</option>
                <option value="rainviewer">RainViewer</option>
                <option value="none">None</option>
            </select>
        </div>

        <script>
            /*
                Fixed issues with radar, click events, and active alerts.
            */

            // Add these variables at the top of your script section, right after <script> tag
            let flashingInterval = null;
            let currentFlashingAlertId = null;
            // Add this variable to track which alert was flashing
            let lastSelectedFeatureId = null;
            // Add this variable to store more details about the selected alert
            let lastSelectedAlertDetails = null;

            // Mapbox Access Token
            mapboxgl.accessToken = 'pk.eyJ1Ijoic3RldmViNzgiLCJhIjoiY205aTRyM3R6MGNjdzJycHl3ajIycWk1MCJ9.1TxPuoQa-jAN7eUi5RR_ag';

            library.createSession().then(() => {
                library.init();
                widgets.functions.init();

                // Initialize Mapbox map
                widgets.map.create = function () {
                    console.log('Initializing Mapbox map...');
                    widgets.map.instance = new mapboxgl.Map({
                        container: 'interactive-map', // Ensure this matches the ID in the HTML
                        style: 'mapbox://styles/steveb78/cm9nasayi00gs01rw4ah5blzc', // Restore your custom gray/silver style
                        center: [-98.5795, 39.8283],
                        zoom: 4,
                        attributionControl: false
                    });

                    // Wait for the map's style to load before adding sources or layers
                    widgets.map.instance.on('load', () => {
                        console.log('Map style loaded.');

                        // Fetch and display weather alerts
                        updateWeatherAlerts();

                        // Refresh weather alerts every 2 minutes
                        setInterval(updateWeatherAlerts, 120000);

                        // Fetch NOAA radar data and add it to the map
                        fetchNOAARadar();

                        // Refresh NOAA radar data every 2 minutes
                        setInterval(fetchNOAARadar, 120000);

                        // Fetch and display Local Storm Reports (LSRs)
                        fetchLocalStormReportsFromKMZ();

                        // Refresh LSR data every 10 minutes (600,000 milliseconds)
                        setInterval(fetchLocalStormReportsFromKMZ, 600000);

                        // Setup radar toggle AFTER everything is loaded
                        setTimeout(() => {
                            setupRadarSourceToggle();
                        }, 1000);
                    });

                    widgets.map.instance.on('error', (e) => {
                        console.error('Map error:', e);
                    });
                };

                // Function to fetch and update weather alerts
                async function updateWeatherAlerts() {
                    try {
                        // Save the ID of the currently flashing alert before refresh
                        if (currentFlashingAlertId) {
                            lastSelectedFeatureId = currentFlashingAlertId;
                        }
                        
                        // Fetch weather GeoJSON data
                        const response = await fetch('https://api.weather.gov/alerts/active?status=actual&message_type=alert');
                        if (!response.ok) throw new Error('Network response was not ok');
                        const data = await response.json();
                        console.log('Weather alerts data:', data);

                        // Filter features with valid polygons or multipolygons
                        const polygonFeatures = data.features.filter(f => 
                            hasValidCoordinates(f) && 
                            (f.geometry.type === "Polygon" || f.geometry.type === "MultiPolygon")
                        );

                        if (polygonFeatures.length === 0) {
                            console.warn('No polygon features found in the weather alerts data.');
                            return; // Do not proceed if there are no polygons
                        }

                        const polygonGeoJSON = {
                            type: "FeatureCollection",
                            features: polygonFeatures
                        };

                        // Remove existing sources and layers to prevent duplicates
                        if (widgets.map.instance.getSource('weather-alerts')) {
                            widgets.map.instance.removeLayer('weather-alerts-layer');
                            widgets.map.instance.removeLayer('weather-alerts-outline');
                            widgets.map.instance.removeSource('weather-alerts');
                        }

                        // Add weather alerts source
                        widgets.map.instance.addSource('weather-alerts', {
                            type: 'geojson',
                            data: polygonGeoJSON
                        });

                        // Add weather alerts layers
                        widgets.map.instance.addLayer({
                            id: 'weather-alerts-layer',
                            type: 'fill',
                            source: 'weather-alerts',
                            paint: {
                                'fill-opacity': 0 // Set fill opacity to 0 to remove shading
                            }
                        });

                        widgets.map.instance.addLayer({
                            id: 'weather-alerts-outline',
                            type: 'line',
                            source: 'weather-alerts',
                            paint: {
                                'line-color': [
                                    'match',
                                    ['downcase', ['get', 'event']],
                                    'flood warning', '#2e7031',      // Darker green
                                    'flash flood warning', '#2e7031',
                                    'tornado warning', '#b71c1c',    // Darker red
                                    'tornado emergency', '#7f0000',  // Even darker red
                                    'severe weather statement', '#e65100', // Darker Orange for SWS
                                    'severe thunderstorm warning', '#b8860b', // Darker yellow/gold
                                    'tornado watch', '#ff8f00',      // Darker gold for Tornado Watch
                                    'severe thunderstorm watch', '#0d47a1', // Darker blue for Severe T-storm Watch
                                    // Default outline color
                                    '#1565c0'
                                ],
                                'line-width': 7
                            }
                        });

                        // Add click event to show alert details in the custom alert box
                        widgets.map.instance.on('click', 'weather-alerts-layer', (e) => {
                            const features = e.features[0];
                            const properties = features.properties;

                            populateAlertBox(properties);
                        });

                        // Add click event to handle multiple overlapping alerts
                        widgets.map.instance.on('click', 'weather-alerts-layer', (e) => {
                            const features = e.features; // Get all features at the clicked location
                        
                            if (features.length > 1) {
                                // If multiple alerts overlap, display a list for the user to choose from
                                const alertSelectionBox = document.createElement('div');
                                alertSelectionBox.style.position = 'absolute';
                                alertSelectionBox.style.top = `${e.point.y}px`;
                                alertSelectionBox.style.left = `${e.point.x}px`;
                                alertSelectionBox.style.background = 'white';
                                alertSelectionBox.style.border = '1px solid #ccc';
                                alertSelectionBox.style.padding = '10px';
                                alertSelectionBox.style.zIndex = '1001';
                                alertSelectionBox.style.fontFamily = 'Arial, sans-serif';
                                alertSelectionBox.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
                        
                                // Add a title to the selection box
                                const title = document.createElement('h4');
                                title.textContent = 'Select an Alert';
                                title.style.margin = '0 0 10px 0';
                                title.style.fontSize = '16px';
                                title.style.fontWeight = 'bold';
                                alertSelectionBox.appendChild(title);
                        
                                // Add each alert to the selection box
                                features.forEach((feature, index) => {
                                    const alertButton = document.createElement('button');
                                    alertButton.textContent = feature.properties.headline || feature.properties.event || `Alert ${index + 1}`;
                                    alertButton.style.display = 'block';
                                    alertButton.style.margin = '5px 0';
                                    alertButton.style.padding = '5px';
                                    alertButton.style.width = '100%';
                                    alertButton.style.textAlign = 'left';
                                    alertButton.style.border = '1px solid #ccc';
                                    alertButton.style.background = '#f9f9f9';
                                    alertButton.style.cursor = 'pointer';
                        
                                    // Add click event to display the selected alert in the red alert box
                                    alertButton.addEventListener('click', () => {
                                        const properties = feature.properties;
                        
                                        // Populate the custom red alert box
                                        document.getElementById('alert-box-title').textContent = properties.headline || properties.event || 'Weather Alert';
                                        document.getElementById('alert-box-expires').textContent = `Expires: ${properties.expires || 'Unknown'}`;
                                        document.getElementById('alert-box-areas').textContent = `Areas: ${properties.areaDesc || 'Unknown'}`;
                                        document.getElementById('alert-box-source').textContent = `Source: ${properties.senderName || 'Unknown'}`;
                                        document.getElementById('alert-box-type').textContent = `Type: ${properties.event || 'Unknown'}`;
                        
                                        // Display the red alert box
                                        const alertBox = document.getElementById('custom-alert-box');
                                        alertBox.style.display = 'block';
                        
                                        // Remove the selection box
                                        document.body.removeChild(alertSelectionBox);
                                    });
                        
                                    alertSelectionBox.appendChild(alertButton);
                                });
                        
                                // Add the selection box to the document
                                document.body.appendChild(alertSelectionBox);
                        
                                // Remove the selection box if the user clicks outside of it
                                document.addEventListener('click', function removeSelectionBox(event) {
                                    if (!alertSelectionBox.contains(event.target)) {
                                        document.body.removeChild(alertSelectionBox);
                                        document.removeEventListener('click', removeSelectionBox);
                                    }
                                });
                            } else if (features.length === 1) {
                                // If only one alert is present, display it directly in the red alert box
                                const properties = features[0].properties;
                        
                                // Populate the custom red alert box
                                document.getElementById('alert-box-title').textContent = properties.headline || properties.event || 'Weather Alert';
                                document.getElementById('alert-box-expires').textContent = `Expires: ${properties.expires || 'Unknown'}`;
                                document.getElementById('alert-box-areas').textContent = `Areas: ${properties.areaDesc || 'Unknown'}`;
                                document.getElementById('alert-box-source').textContent = `Source: ${properties.senderName || 'Unknown'}`;
                                document.getElementById('alert-box-type').textContent = `Type: ${properties.event || 'Unknown'}`;
                        
                                // Display the red alert box
                                const alertBox = document.getElementById('custom-alert-box');
                                alertBox.style.display = 'block';
                            }
                        });

                        widgets.map.instance.on('click', 'weather-alerts-layer', (e) => {
                            const feature = e.features[0]; // Get the first feature at the clicked location
                            const properties = feature.properties;

                            // Populate the custom alert box
                            document.getElementById('alert-box-title').textContent = properties.headline || properties.event || 'Weather Alert';
                            document.getElementById('alert-box-expires').textContent = `Expires: ${properties.expires || 'Unknown'}`;
                            document.getElementById('alert-box-areas').textContent = `Areas: ${properties.areaDesc || 'Unknown'}`;
                            document.getElementById('alert-box-source').textContent = `Source: ${properties.senderName || 'Unknown'}`;
                            document.getElementById('alert-box-type').textContent = `Type: ${properties.event || 'Unknown'}`;

                            // Start flashing the selected polygon
                            startFlashingPolygon(feature);

                            // Display the red alert box
                            const alertBox = document.getElementById('custom-alert-box');
                            alertBox.style.display = 'block';

                            // Zoom to the alert's geometry
                            if (feature.geometry) {
                                const coordinates = feature.geometry.coordinates;

                                // Handle Polygon and MultiPolygon geometries
                                let flattenedCoordinates = [];
                                if (feature.geometry.type === "Polygon") {
                                    flattenedCoordinates = coordinates.flat(1); // Flatten one level for Polygon
                                } else if (feature.geometry.type === "MultiPolygon") {
                                    flattenedCoordinates = coordinates.flat(2); // Flatten two levels for MultiPolygon
                                }

                                // Ensure the coordinates are valid [lng, lat] pairs
                                const validCoordinates = flattenedCoordinates.filter(coord => Array.isArray(coord) && coord.length === 2);

                                if (validCoordinates.length > 0) {
                                    // Create a bounding box from the valid coordinates
                                    const bounds = validCoordinates.reduce(
                                        (b, coord) => b.extend(coord),
                                        new mapboxgl.LngLatBounds(validCoordinates[0], validCoordinates[0])
                                    );

                                    // Fit the map to the bounding box
                                    widgets.map.instance.fitBounds(bounds, { padding: 50 });
                                } else {
                                    console.error("No valid coordinates found for the selected alert.");
                                }
                            } else {
                                console.error("No geometry found for the selected alert.");
                            }
                        });

                        // Hide the red alert box when clicking outside the polygons
                        widgets.map.instance.on('click', (e) => {
                            const features = widgets.map.instance.queryRenderedFeatures(e.point, {
                                layers: ['weather-alerts-layer']
                            });

                            if (!features.length) {
                                const alertBox = document.getElementById('custom-alert-box');
                                alertBox.style.display = 'none';
                                
                                // Stop flashing when clicking outside polygons
                                stopFlashingPolygon();
                            }
                        });

                        // Change the cursor to a pointer when hovering over the alerts
                        widgets.map.instance.on('mouseenter', 'weather-alerts-layer', () => {
                            widgets.map.instance.getCanvas().style.cursor = 'pointer';
                        });

                        widgets.map.instance.on('mouseleave', 'weather-alerts-layer', () => {
                            widgets.map.instance.getCanvas().style.cursor = '';
                        });

                        // Populate the alert list and add click events
                        const alertList = document.getElementById('alert-items');
                        alertList.innerHTML = ''; // Clear existing items
                        polygonFeatures.forEach((feature, index) => {
                            const alertTitle = feature.properties.headline || feature.properties.event || `Alert ${index + 1}`;
                            console.log('Adding alert to list:', alertTitle);
                            const listItem = document.createElement('li');
                            listItem.textContent = alertTitle;
                            listItem.style.cursor = 'pointer';
                            listItem.style.padding = '5px 0';
                            listItem.style.borderBottom = '1px solid #ddd';

                            // Add click event to show the alert in the custom alert box
                            listItem.addEventListener('click', () => {
                                const properties = feature.properties;

                                populateAlertBox(properties);
                                
                                // Start flashing the selected polygon
                                startFlashingPolygon(feature);

                                // Zoom to the alert's geometry
                                if (feature.geometry) {
                                    const coordinates = feature.geometry.coordinates;

                                    // Handle Polygon and MultiPolygon geometries
                                    let flattenedCoordinates = [];
                                    if (feature.geometry.type === "Polygon") {
                                        flattenedCoordinates = coordinates.flat(1); // Flatten one level for Polygon
                                    } else if (feature.geometry.type === "MultiPolygon") {
                                        flattenedCoordinates = coordinates.flat(2); // Flatten two levels for MultiPolygon
                                    }

                                    // Ensure the coordinates are valid [lng, lat] pairs
                                    const validCoordinates = flattenedCoordinates.filter(coord => Array.isArray(coord) && coord.length === 2);

                                    if (validCoordinates.length > 0) {
                                        // Create a bounding box from the valid coordinates
                                        const bounds = validCoordinates.reduce(
                                            (b, coord) => b.extend(coord),
                                            new mapboxgl.LngLatBounds(validCoordinates[0], validCoordinates[0])
                                        );

                                        // Fit the map to the bounding box
                                        widgets.map.instance.fitBounds(bounds, { padding: 50 });
                                    } else {
                                        console.error("No valid coordinates found for the selected alert.");
                                    }
                                } else {
                                    console.error("No geometry found for the selected alert.");
                                }
                            });

                            alertList.appendChild(listItem);
                        });

                        // Re-flash the previously selected alert if it exists in the new data
                        if (lastSelectedFeatureId) {
                            console.log('Attempting to restore flash animation', lastSelectedFeatureId);
                            console.log('Last selected alert details:', lastSelectedAlertDetails);
                            
                            // Try to find the matching alert in the new data
                            const previouslySelectedFeature = findMatchingAlert(polygonFeatures, lastSelectedFeatureId);
                            
                            if (previouslySelectedFeature) {
                                console.log('Found matching alert to restore flashing');
                                // Use a longer timeout to ensure everything is initialized
                                setTimeout(() => {
                                    // Completely recreate the flashing effect
                                    startFlashingPolygon(previouslySelectedFeature);
                                    
                                    // Make sure the alert box is still displayed
                                    const alertBox = document.getElementById('custom-alert-box');
                                    if (alertBox.style.display !== 'block') {
                                        alertBox.style.display = 'block';
                                    }
                                    
                                    // Re-populate the alert box just to be sure
                                    populateAlertBox(previouslySelectedFeature.properties);
                                }, 1000); // Increased timeout for better reliability
                            } else {
                                console.log('Previously selected alert no longer exists in the data');
                                // Don't clear the IDs here, as the alert might come back in a future update
                            }
                        }

                        console.log('Weather alerts updated successfully.');
                    } catch (error) {
                        console.error('Failed to fetch weather data:', error);

                        // If the fetch fails, do not remove the existing polygons
                        console.warn('Keeping existing polygons to avoid disappearing layers.');
                    }
                };

                // Function to fetch NOAA radar data and add it to the map
                function fetchNOAARadar() {
                    // Request higher resolution tiles (512x512 instead of 256x256)
                    const noaaRadarUrl = 'https://opengeo.ncep.noaa.gov/geoserver/conus/conus_bref_qcd/ows?service=WMS&version=1.3.0&request=GetMap&layers=conus_bref_qcd&styles=&crs=EPSG:3857&bbox={bbox-epsg-3857}&width=512&height=512&format=image/png&transparent=true';

                    // Ensure the map instance is initialized before proceeding
                    if (!widgets.map.instance) {
                        console.error('Map instance is not initialized.');
                        return;
                    }

                    try {
                        // Check if the radar source already exists
                        if (widgets.map.instance.getSource('noaa-radar')) {
                            console.log('Radar source already exists. Updating the radar layer...');
                            // Update the existing source with new higher-res tiles - SAFER VERSION
                            widgets.map.instance.getSource('noaa-radar').tiles = [noaaRadarUrl];
                            
                            // Only update the source cache if it exists
                            if (widgets.map.instance.style && 
                                widgets.map.instance.style.sourceCaches && 
                                widgets.map.instance.style.sourceCaches['noaa-radar']) {
                                widgets.map.instance.style.sourceCaches['noaa-radar']._source.tiles = [noaaRadarUrl];
                            }
                            
                            widgets.map.instance.triggerRepaint();
                        } else {
                            // Add NOAA WMS radar source with higher resolution settings
                            widgets.map.instance.addSource('noaa-radar', {
                                type: 'raster',
                                tiles: [noaaRadarUrl],
                                tileSize: 512, // Larger tile size for better resolution
                                attribution: 'Radar: NOAA/NWS'
                            });

                            // Add NOAA WMS radar layer with improved rendering
                            widgets.map.instance.addLayer({
                                id: 'noaa-radar-layer',
                                type: 'raster',
                                source: 'noaa-radar',
                                paint: {
                                    'raster-opacity': 0.7,
                                    'raster-resampling': 'linear', // Linear interpolation for smoother appearance
                                    'raster-fade-duration': 300    // Smooth transition between tiles (in milliseconds)
                                }
                            });

                            console.log('Added high-resolution NOAA radar layer.');
                        }
                    } catch (error) {
                        console.error('Failed to add or update NOAA radar layer:', error);
                    }
                }

                // Fetch NOAA radar data on page load
                fetchNOAARadar();

                // Refresh NOAA radar data every 10 minutes (600,000 milliseconds)
                setInterval(fetchNOAARadar, 600000);

                // Fetch RainViewer radar data
                fetchRainViewerRadar();

                // Refresh RainViewer radar data every 5 minutes
                setInterval(fetchRainViewerRadar, 300000);

                widgets.map.create();
            });

            // Add event listener to the close button
            document.getElementById('alert-box-close').addEventListener('click', () => {
                const alertBox = document.getElementById('custom-alert-box');
                alertBox.style.display = 'none';
                
                // Stop the flashing animation when the alert box is closed
                stopFlashingPolygon();
            });

            // Function to populate the alert box
            function populateAlertBox(properties) {
                // Format the expiration time to the local time of the alert
                const expires = new Date(properties.expires).toLocaleString('en-US', {
                    timeZone: properties.timeZone || 'America/New_York', // Use the alert's time zone or default to Eastern Time
                    hour12: true,
                    hour: '2-digit',
                    minute: '2-digit',
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    timeZoneName: 'short' // Display the time zone abbreviation (e.g., EDT, CST)
                });

                // Set colors based on the event type
                const eventType = properties.event?.toLowerCase() || 'unknown';
                let boxColor, line1Color, line2Color, line3Color, line4Color, line5Color;

                if (eventType.includes('tornado warning')) {
                    boxColor = '#b71c1c'; // Dark red
                    line1Color = '#000000'; // Darkest red
                    line2Color = '#d32f2f'; // Slightly lighter red
                    line3Color = '#c62828'; // Medium red
                    line4Color = '#b71c1c'; // Darker red
                    line5Color = '#ff0000'; // Bright red
                } else if (eventType.includes('severe thunderstorm')) {
                    boxColor = '#ffaa00'; // Light yellow
                    line1Color = '#000000'; // Darkest red
                    line2Color = '#fdd835'; // Slightly darker yellow
                    line3Color = '#fbc02d'; // Yellow
                    line4Color = '#f9a825'; // Darker yellow
                    line5Color = '#f57f17'; // Darkest yellow
                } else if (eventType.includes('flash flood') || eventType.includes('flood')) {
                    boxColor = '#00b300'; // Light green
                    line1Color = '#000000'; // Green
                    line2Color = '#66bb6a'; // Slightly lighter green
                    line3Color = '#43a047'; // Green
                    line4Color = '#2e7d32'; // Darker green
                    line5Color = '#1b5e20'; // Darkest green
                } else {
                    boxColor = '#0080ff'; // Light blue
                    line1Color = '#000000'; // Blue
                    line2Color = '#2196f3'; // Slightly lighter blue
                    line3Color = '#1976d2'; // Blue
                    line4Color = '#1565c0'; // Darker blue
                    line5Color = '#0d47a1'; // Darkest blue
                }

                // Apply colors to the alert box and its elements
                const alertBox = document.getElementById('custom-alert-box');
                alertBox.style.background = boxColor;

                document.getElementById('alert-box-event').style.background = line1Color;
                document.getElementById('alert-box-expires').style.background = line2Color;
                document.getElementById('alert-box-areas').style.background = line3Color;
                document.getElementById('alert-box-max-wind').style.background = line4Color;
                document.getElementById('alert-box-max-hail').style.background = line5Color;

                // Populate the custom alert box
                document.getElementById('alert-box-event').textContent = properties.event || 'Unknown Event';
                document.getElementById('alert-box-expires').textContent = `Expires: ${expires}`;
                document.getElementById('alert-box-areas').textContent = `Areas: ${properties.areaDesc || 'Unknown'}`;
                document.getElementById('alert-box-max-wind').textContent = `Max Wind Gust: ${properties.parameters?.maxWindGust || 'Unknown'}`;
                document.getElementById('alert-box-max-hail').textContent = `Max Hail Size: ${properties.parameters?.maxHailSize || 'Unknown'}`;

                // Display the alert box
                alertBox.style.display = 'block';
            }

            // Function to fetch and display Local Storm Reports (LSRs)
            async function fetchLocalStormReports() {
                try {
                    // Fetch LSR data from the NWS API
                    const response = await fetch('https://api.weather.gov/reports');
                    if (!response.ok) throw new Error('Failed to fetch LSR data');
                    const lsrData = await response.json();

                    console.log('Local Storm Reports data:', lsrData);

                    // Filter valid features with Point geometries
                    const pointFeatures = lsrData.features.filter(
                        f => f.geometry && f.geometry.type === "Point"
                    );

                    if (pointFeatures.length === 0) {
                        console.warn('No valid LSR features found.');
                        return;
                    }

                    const lsrGeoJSON = {
                        type: "FeatureCollection",
                        features: pointFeatures
                    };

                    // Add LSR source to the map
                    if (widgets.map.instance.getSource('local-storm-reports')) {
                        widgets.map.instance.getSource('local-storm-reports').setData(lsrGeoJSON);
                    } else {
                        widgets.map.instance.addSource('local-storm-reports', {
                            type: 'geojson',
                            data: lsrGeoJSON
                        });

                        // Add LSR layer to the map
                        widgets.map.instance.addLayer({
                            id: 'local-storm-reports-layer',
                            type: 'circle',
                            source: 'local-storm-reports',
                            paint: {
                                'circle-radius': 6,
                                'circle-color': [
                                    'match',
                                    ['get', 'event'],
                                    'Tornado', '#b71c1c', // Red for tornadoes
                                    'Hail', '#4caf50',    // Green for hail
                                    'Wind', '#2196f3',    // Blue for wind
                                    /* Default color */ '#ff9800' // Orange for other events
                                ],
                                'circle-stroke-width': 1,
                                'circle-stroke-color': '#000000' // Black border
                            }
                        });

                        console.log('Added Local Storm Reports layer.');
                    }
                } catch (error) {
                    console.error('Error fetching or displaying LSR data:', error);
                }
            }

            // Function to fetch and display Local Storm Reports (LSRs) from KMZ
            async function fetchLocalStormReportsFromKMZ() {
                try {
                    // Fetch the KMZ file
                    const response = await fetch('https://www.spc.noaa.gov/climo/reports/today.kmz');
                    if (!response.ok) throw new Error('Failed to fetch LSR KMZ file');
                    const kmzBlob = await response.blob();

                    // Use JSZip to extract the KMZ file
                    const zip = new JSZip();
                    const kmzData = await zip.loadAsync(kmzBlob);

                    // Find the KML file inside the KMZ
                    const kmlFileName = Object.keys(kmzData.files).find(name => name.endsWith('.kml'));
                    if (!kmlFileName) throw new Error('No KML file found in the KMZ');

                    const kmlContent = await kmzData.files[kmlFileName].async('string');

                    // Convert KML to GeoJSON
                    const geojson = toGeoJSON.kml(new DOMParser().parseFromString(kmlContent, 'text/xml'));

                    // Filter out features with invalid coordinates
                    if (geojson && geojson.features) {
                        geojson.features = geojson.features.filter(hasValidCoordinates);
                        console.log(`Filtered to ${geojson.features.length} valid LSR features`);
                    }

                    console.log('Local Storm Reports GeoJSON:', geojson);

                    // Add LSR source to the map
                    if (widgets.map.instance.getSource('local-storm-reports')) {
                        widgets.map.instance.getSource('local-storm-reports').setData(geojson);
                    } else {
                        widgets.map.instance.addSource('local-storm-reports', {
                            type: 'geojson',
                            data: geojson
                        });

                        // Add LSR layer to the map
                        widgets.map.instance.addLayer({
                            id: 'local-storm-reports-layer',
                            type: 'circle',
                            source: 'local-storm-reports',
                            paint: {
                                'circle-radius': 6,
                                'circle-color': [
                                    'match',
                                    ['get', 'event'],
                                    'Tornado', '#b71c1c', // Red for tornadoes
                                    'Hail', '#4caf50',    // Green for hail
                                    'Wind', '#2196f3',    // Blue for wind
                                    /* Default color */ '#ff9800' // Orange for other events
                                ],
                                'circle-stroke-width': 1,
                                'circle-stroke-color': '#000000' // Black border
                            }
                        });

                        console.log('Added Local Storm Reports layer.');
                    }
                } catch (error) {
                    console.error('Error fetching or displaying LSR data from KMZ:', error);
                }
            }

            // Fetch LSR data on page load
            fetchLocalStormReportsFromKMZ();

            // Refresh LSR data every 10 minutes (600,000 milliseconds)
            setInterval(fetchLocalStormReportsFromKMZ, 600000);

            // Add click event for LSR points
            widgets.map.instance.on('click', 'local-storm-reports-layer', (e) => {
                const feature = e.features[0];
                const properties = feature.properties;

                // Create a popup with LSR details
                new mapboxgl.Popup()
                    .setLngLat(feature.geometry.coordinates)
                    .setHTML(`
                        <strong>Event:</strong> ${properties.event || 'Unknown'}<br>
                        <strong>Location:</strong> ${properties.location || 'Unknown'}<br>
                        <strong>Time:</strong> ${new Date(properties.time).toLocaleString() || 'Unknown'}<br>
                        <strong>Details:</strong> ${properties.details || 'No details available'}
                    `)
                    .addTo(widgets.map.instance);
            });

            // Change the cursor to a pointer when hovering over LSR points
            widgets.map.instance.on('mouseenter', 'local-storm-reports-layer', () => {
                widgets.map.instance.getCanvas().style.cursor = 'pointer';
            });

            widgets.map.instance.on('mouseleave', 'local-storm-reports-layer', () => {
                widgets.map.instance.getCanvas().style.cursor = '';
            });

            // Variables to track polygon flashing animation
            //let flashingInterval = null;
            //let currentFlashingAlertId = null;

            // Function to stop the flashing animation
            function stopFlashingPolygon() {
                if (flashingInterval !== null) {
                    clearInterval(flashingInterval);
                    flashingInterval = null;
                    console.log('Flashing animation stopped');
                }
                
                // Don't hide the layer, just stop the animation
                // We no longer want to remove the currentFlashingAlertId either
            }

            // Function to start flashing animation for a selected polygon
            function startFlashingPolygon(feature) {
                console.log('Starting flash animation for feature:', feature.properties?.event || 'Unknown Alert');
                
                // Stop any existing animation first, but don't clear IDs
                if (flashingInterval !== null) {
                    clearInterval(flashingInterval);
                    flashingInterval = null;
                }
                
                // Generate a unique ID for this feature
                currentFlashingAlertId = feature.id || feature.properties?.id || `alert-${Date.now()}`;
                // Also update the lastSelectedFeatureId
                lastSelectedFeatureId = currentFlashingAlertId;
                
                // Store additional details about this alert for more robust matching
                if (feature.properties) {
                    lastSelectedAlertDetails = {
                        event: feature.properties.event,
                        headline: feature.properties.headline,
                        areaDesc: feature.properties.areaDesc,
                        // Add more distinctive properties if available
                        effective: feature.properties.effective,
                        expires: feature.properties.expires
                    };
                }
                
                // Create a GeoJSON source with just this selected feature
                const selectedFeatureGeoJSON = {
                    type: "FeatureCollection",
                    features: [feature]
                };
                
                // Create or update the selected alert layer
                if (!widgets.map.instance.getSource('selected-alert')) {
                    console.log('Creating new selected-alert source');
                    widgets.map.instance.addSource('selected-alert', {
                        type: 'geojson',
                        data: selectedFeatureGeoJSON
                    });
                    
                    widgets.map.instance.addLayer({
                        id: 'selected-alert-outline',
                        type: 'line',
                        source: 'selected-alert',
                        paint: {
                            'line-color': '#ffffff', // White outline
                            'line-width': 4,
                            'line-opacity': 1,
                            'line-dasharray': [2, 2] // Dashed line for better visibility
                        }
                    });
                } else {
                    console.log('Updating existing selected-alert source');
                    widgets.map.instance.getSource('selected-alert').setData(selectedFeatureGeoJSON);
                }
                
                // Set up the flashing animation with alternating opacity
                let visible = true;
                flashingInterval = setInterval(() => {
                    visible = !visible;
                    if (widgets.map.instance.getLayer('selected-alert-outline')) {
                        widgets.map.instance.setPaintProperty(
                            'selected-alert-outline',
                            'line-opacity',
                            visible ? 1 : 0
                        );
                    } else {
                        console.warn('selected-alert-outline layer not found during animation');
                        // If the layer is gone, stop the interval to avoid errors
                        clearInterval(flashingInterval);
                        flashingInterval = null;
                    }
                }, 500); // Flash every 500ms
            }

            // Add this function near your other utility functions
            function findMatchingAlert(polygonFeatures, previousId) {
                // First try to find by ID
                let match = polygonFeatures.find(f => 
                    f.id === previousId || 
                    (f.properties && f.properties.id === previousId)
                );
                
                if (match) {
                    console.log('Found exact ID match for previously selected alert');
                    return match;
                }
                
                // If we stored the alert details, try to match by properties
                if (lastSelectedAlertDetails) {
                    match = polygonFeatures.find(f => 
                        f.properties && 
                        f.properties.event === lastSelectedAlertDetails.event &&
                        f.properties.headline === lastSelectedAlertDetails.headline &&
                        f.properties.areaDesc === lastSelectedAlertDetails.areaDesc
                    );
                    
                    if (match) {
                        console.log('Found property match for previously selected alert');
                        return match;
                    }
                }
                
                console.log('No matching alert found');
                return null;
            }

            // Function to fetch and display RainViewer radar data
            async function fetchRainViewerRadar() {
                try {
                    console.log('Fetching RainViewer radar data...');
                    const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                    if (!response.ok) throw new Error('Failed to fetch RainViewer radar data');
                    const data = await response.json();

                    // Log the structure of the response for debugging
                    console.log('RainViewer API Response structure:', 
                        Object.keys(data).join(', '), 
                        data.radar ? 'has radar' : 'no radar',
                        data.satellite ? 'has satellite' : 'no satellite');

                    // Get the latest radar frame from the updated API structure
                    if (data.radar && data.radar.past && data.radar.past.length > 0) {
                        // Use the most recent past radar frame
                        const latestFrame = data.radar.past[data.radar.past.length - 1];
                        const radarUrl = `https://tilecache.rainviewer.com${latestFrame.path}/256/{z}/{x}/{y}/2/1_1.png`;
                        
                        console.log('Found valid radar path:', latestFrame.path);
                        addRainViewerLayer(radarUrl);
                        return;
                    }
                    
                    // Fallback to the public endpoint format
                    if (data.host && data.radar && data.radar.nowcast) {
                        const frame = data.radar.nowcast[0];
                        const host = data.host;
                        const radarUrl = `${host}${frame.path}/256/{z}/{x}/{y}/2/1_1.png`;
                        
                        console.log('Using nowcast radar path:', frame.path);
                        addRainViewerLayer(radarUrl);
                        return;
                    }

                    // Try the standard RainViewer format as another fallback
                    const currentTimestamp = Math.floor(Date.now() / 1000);
                    const radarUrl = `https://tilecache.rainviewer.com/v2/radar/nowcast/${currentTimestamp}/256/{z}/{x}/{y}/2/1_1.png`;
                    console.log('Using fallback timestamp-based URL');
                    addRainViewerLayer(radarUrl);

                } catch (error) {
                    console.error('Error fetching or displaying RainViewer radar data:', error);
                }
            }

            // Helper function to add or update the RainViewer layer
            function addRainViewerLayer(radarUrl) {
                if (widgets.map.instance.getSource('rainviewer-radar')) {
                    widgets.map.instance.getSource('rainviewer-radar').tiles = [radarUrl];
                    console.log('Updated existing RainViewer radar source');
                    widgets.map.instance.triggerRepaint();
                } else {
                    widgets.map.instance.addSource('rainviewer-radar', {
                        type: 'raster',
                        tiles: [radarUrl],
                        tileSize: 512
                    });

                    widgets.map.instance.addLayer({
                        id: 'rainviewer-radar-layer',
                        type: 'raster',
                        source: 'rainviewer-radar',
                        paint: {
                            'raster-opacity': 0.7,
                            'raster-resampling': 'linear',
                            'raster-fade-duration': 300
                        },
                        layout: {
                            'visibility': 'none' // Hidden by default until selected
                        }
                    });

                    console.log('Added RainViewer radar layer (hidden by default)');
                }

                // Make sure RainViewer layer is above the map base but below alerts
                if (widgets.map.instance.getLayer('weather-alerts-layer')) {
                    widgets.map.instance.moveLayer('rainviewer-radar-layer', 'weather-alerts-layer');
                }
            }

            // Replace your existing radar select event listener with this version
            function setupRadarSourceToggle() {
                const select = document.getElementById('radar-select');
                if (!select) {
                    console.error('Radar select element not found');
                    return;
                }

                select.addEventListener('change', function(e) {
                    if (!widgets.map.instance) {
                        console.error('Map not initialized yet');
                        return;
                    }
                    
                    const selectedValue = e.target.value;
                    console.log('Changing radar source to:', selectedValue);
                    
                    // Use a longer timeout to ensure layers are fully loaded
                    setTimeout(() => {
                        try {
                            // First hide all radar layers
                            const radarLayers = ['noaa-radar-layer', 'rainviewer-radar-layer'];
                            radarLayers.forEach(layerId => {
                                if (widgets.map.instance.getLayer(layerId)) {
                                    widgets.map.instance.setLayoutProperty(layerId, 'visibility', 'none');
                                    console.log(`${layerId} hidden`);
                                }
                            });
                            
                            // Then show only the selected layer
                            if (selectedValue !== 'none') {
                                const selectedLayerId = selectedValue === 'noaa' ? 'noaa-radar-layer' : 'rainviewer-radar-layer';
                                if (widgets.map.instance.getLayer(selectedLayerId)) {
                                    widgets.map.instance.setLayoutProperty(selectedLayerId, 'visibility', 'visible');
                                    console.log(`${selectedLayerId} now visible`);
                                } else {
                                    console.warn(`${selectedLayerId} not found - may still be loading`);
                                }
                            }
                        } catch (error) {
                            console.error('Error changing radar source:', error);
                        }
                    }, 500); // Increased timeout
                });
                
                // Set default radar source to NOAA on page load
                select.value = 'noaa';
                // Trigger the change event to apply the default selection
                select.dispatchEvent(new Event('change'));
            }

            // Add this function to help validate coordinates
            function hasValidCoordinates(feature) {
                if (!feature.geometry || !feature.geometry.coordinates) return false;
                
                if (feature.geometry.type === 'Point') {
                    return Array.isArray(feature.geometry.coordinates) && 
                           feature.geometry.coordinates.length === 2 && 
                           feature.geometry.coordinates.every(coord => typeof coord === 'number');
                }
                
                if (feature.geometry.type === 'Polygon') {
                    return feature.geometry.coordinates.every(ring => 
                        Array.isArray(ring) && ring.every(coord => 
                            Array.isArray(coord) && coord.length === 2 && coord.every(num => typeof num === 'number')
                        )
                    );
                }
                
                if (feature.geometry.type === 'MultiPolygon') {
                    return feature.geometry.coordinates.every(polygon => 
                        Array.isArray(polygon) && polygon.every(ring => 
                            Array.isArray(ring) && ring.every(coord => 
                                Array.isArray(coord) && coord.length === 2 && coord.every(num => typeof num === 'number')
                            )
                        )
                    );
                }
                
                return false;
            }
        </script>
    </body>
</html>
<!-- This is the correct index.html -->